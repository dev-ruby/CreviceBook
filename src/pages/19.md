# 소스와 헤더

작성해야할 함수의 양이 늘어나 관리하기 힘들어졌을때 함수의 정의와 선언을
분리하여 각각 다른 파일에 작성하면 유지보수가 용이해질 수 있다.

무엇보다, 남들에게 기능을 제공하기 위한 목적으로 코드를 작성해야하는
입장에서(string.h 혹은 stdio.h 등을 구현한다고 생각해보자) 세세한 구현
대신 대략적인 구현 방법만을 알려주는 것이 효율적일 것이다.

이렇게 선언과 정의가 분리되었을때, 정의가 모아져있는 파일을 소스(Source),
선언이 모아져있는 파일을 헤더(header )라고 한다. (이전에 살펴본 stdio.h
나 string.h 또한 이 헤더의 일종이다; 헤더와 소스를 분리하기 위해, 헤더
파일은 보통 .h 확장자, 소스 파일은 보통 .c 확장자를 사용한다)

소스와 헤더를 분리해 발생할 수 있는 한 시나리오를 가정해보자: 소스 파
일이 분석되고 실행할 수 있는 결과물로 변환될때, 컴파일(Compile)과 링크
(Link)의 두 과정을 거친다. (각각을 수행하는 프로그램을 컴파일러, 링커라고
부른다)

a.h와 a.c에서 함수 a가 각각 선언/정의되고, b.c에서 a.h를 include하여
함수 a를 참조했다고 가정해보자.

먼저 컴파일 과정에서 a.c와 b.c가 분석되고 중간 파일이 생성되는데, a.c
에 함수 a의 선언과 정의에 관한 정보, b.c에 a의 선언에 관한 정보가 담긴다.

다음 링크 과정에서 b.c에서 비롯된 a의 선언이 a.c에 의해 정의됨을 확
인함으로써, b.c와 a.c에 의해 선언된 두 함수 a가 실질적으로 같은 함수를
가리키도록 한다. (함수 또한 컴퓨터의 메모리 어딘가에 저장되므로)

만약 a.c가 링크 혹은 컴파일 과정에서 제외되었다면 어떤 일이 생길까?
컴파일 과정에서 a.c가 제외되었든, 링크 과정에서 제외되었든, 항상 링크 과
정에서 문제가 발생한다. 먼저, 컴파일러는 b.c를 해석함에 있어서 함수 a가
제대로 선언되었으므로 문제가 없다고 판단할 것이다. 그러나, 링크 과정에서,
b.c에서 선언된 함수 a의 정의를 찾을 수 없으므로 오류가 발생할 것이다.
이렇게 링크 과정에서 발생한 오류를 링크(Linkage) 오류라고 부른다.

외부 사용자에게 내 코드를 쉽게 사용할 수 있도록 하는 방법에는 무엇이
있을까? 내 소스 코드와 헤더 파일들 모두를 복사해 전달할 수도 있겠지만,
헤더 파일만 복사하고 소스 코드를 컴파일한 결과물들을 하나로 합친 아카
이브(Archive)를 만들 수도 있다. 아카이브는 단순히 소스 코드를 컴파일한
중간 파일들을 하나로 묶은 것으로, 이 파일을 링크함으로써 대응되는 헤더
파일들에 선언된 모든 함수들을 사용할 수 있게 된다.

이렇게 외부 사용자가 기능을 쉽게 사용할 수 있도록 배포되는 프로그램을
라이브러리(Library)라고 부른다. 이를 통해, 외부 코드를 사용하는 입장에서
는 오직 헤더 파일만을 참조하고, 링커에게 외부 라이브러리의 아카이브 파일
을 링크하도록 함으로써 프로그램을 확장할 수 있다. (string.h나 stdio.h
등 표준 C 헤더 파일들에 대한 아카이브는 보통 컴파일러에 의해 자동적으로
참조된다)