# 명령집합과 기계어

대신, 컴퓨터는 인위적으로 정의된 명령 집합에 따라 작동한다.
우리도 컴퓨터처럼 아내에게 더욱 엄밀하고 덜 모호하게 명령을 내려달라고 요구하기 위해, 아보카도와 우유를 향한 임무 달성을 위해 다음과 같이 명령 집합을 정의해보자.

<br/>

| 이름   | 매개변수        | 동작                                        |
|------|-------------|-------------------------------------------|
| buy  | 물품 t, 자연수 n | t를 n개만큼 구매한다. 아니라면 0으로 	정의한다.             |
| find | 물품 t        | 물품 t가 존재한다면 r을 1로 정의한다. 아니라면 r을 0으로 정의한다. |
| move | 위치 p        | r이 0이라면 위치 p로 이동한다. 아니라면 아무 동작도 하지 않는다.   |

<br/>

이러한 명령집합을 사용하면 아래와 같이 엄밀하게 우리의 행위를 정의해 볼 수 있다. (명령은 위에서부터 순차적으로 실행한다.)

<br/>

```
buy(우유, 1)
find(아보카도)
move(출구)
buy(아보카도, 6)
```

<br/>

이렇게만 적어도 사람이 프로그램을 수행함에 있어서 어려움은 없다. 그러나, 전류 흐름의 여부로 신호를 처리하는 컴퓨터에게 있어서, 한글과 알파벳을 이해하도록 하는 것은 매우 복잡할 것이다. 따라서, 우리는 다음과
같이 각각의 명령과 단어들에 번호를 부여할 것이다.

<br/>

| 이름   | 번호 | 이름   | 번호 |
|------|----|------|----|
| buy  | 0  | 아보카도 | 0  |
| find | 1  | 우유   | 1  |
| move | 2  | 출구   | 2  |

<br/>

부여된 번호를 통해 다시 구현하면 다음과 같다.

<br/>

```
0(1, 1)
1(0)
2(2)
0(0, 6)
```

<br/>

또한 다음의 규칙에 따라 명령을 기계가 이해하기 쉽도록 바꾸어보자.

- 명령과 상품에는 각각 두자리를 할당하자
- 상품의 갯수에는 네자리를 할당하자

결과는 다음과 같다:

<br/>

```
00 01 0001
01 00
10 10
00 00 0110
```

<br/>

축하한다! 독자는 방금 마트에 가서 우유 (혹은 아보카도)를 구매하기 위한 명령 체계2를 완성했다! 이제 독자는 독자의 아내에게 모호하지 않은 명령을 내려달라고 요구할 수 있을 것이다!

<br/>

...그래서 이 기계어가 C언어랑 무슨 상관일까? 그것은 C언어의 태생에 있다.
자세히 알아보기 위해 1951년으로 돌아가보자.

<br/>

**복잡해지는 ISA와 어셈블리어**

<br/>

컴퓨터를 프로그램하기 위해 0과 1만 두드리고 있는 것은 매우 지루한 일
일 뿐더러, 코드에 오류가 존재하거나 오타를 치고 말았을때 수정하기 매우
번거롭다.

개발자들은 이러한 문제를 해결하기 위해 어셈블리어3를 도입했다. 이는 독자가 설계한 ‘아보카도 명령 코드 (최종)’과 비슷한 것으로, 기계어에 일대일 대응되도록 알파벳으로 이루어진 이름을 부여한 것이다.

다음의 규칙과 함께 아래의 명령을 해석해보자
