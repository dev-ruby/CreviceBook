# 문자열과 문자열 리터럴

C 언어에서 문자열은 다음과 같이 사용한다:

```
char str[] = "Hello, World!";
printf("%s", str);
```

`"`기호를 이용해 str을 초기화하는 것은 다음의 코드를 쉽게 작성하기
위함이다. 아래의 코드는 위 예제와 동치이다:

```
char str[] = {
    ’H’, ’e’, ’l’, ’l’, ’o’, ’,’, ’ ’,
    ’W’, ’o’, ’r’, ’l’, ’d’, ’!’, 0
};
printf("%s", str);
```

이렇게, ‘"’에 감싸진 글을 string literal, 문자열 리터럴이라고 부른다. 비
슷한 맥락에서, ‘a’, ‘b’ 등의 문자 리터럴, 1, 3 등의 숫자 리터럴이 존재한다.
문법적으로 상수가 작성되었을때, 이를 리터럴이라고 부른다고 이해하면 좋을
것 같다.

문자열 리터럴은 사용되는 위치에 따라 그 의미를 달리 한다. 위처럼 어떤
문자열 리터럴이 char str[]을 초기화하기 위해 사용되었을때, str이 초기
화되는 시점에서, str[0]부터 문자열의 마지막까지를 str에 복사한다.

문자열 리터럴을 통해 초기화되는 문자 배열의 크기가 지정되지 않았을때,
문자 배열의 크기는 (마지막의 0을 포함한) 문자열의 길이로 암시된다. 따라
서, Hello, World!은 str[]의 크기를 14로 암시한다(str[14]). 위 예제에서
문자열은 배열에 저장되었기에, 그 내용을 수정할 수 있다:


```
char str[] = "Hello, World!";
str[5] = ’w’;
printf("%s", str);
```

char*를 통해 문자열을 가리키는 김에, 배열이 아닌 char*형 변수를 문자
열 리터럴을 이용해 초기화 할 수 있다:

```
char* str = "Hello, World!";
printf("%s", str);
```

배열에 복사되어 저장될 때와는 달리 ‘Hello, World!’가 따로 메모리 공간에
할당되지 않았음에도 str은 틀림없이 ‘Hello, World!’의 첫 문자를 가리키는
포인터다. 이는 이렇게 특수한 형태로 사용되는 문자열 리터럴들이 특별히
지정된 특수한 공간 2 에 할당되기 때문이다.

문자열 리터럴이 할당된 특수한 공간에서는 읽기(read)만 가능하고 쓰기
(write)가 불가하므로 위와 같은 방법으로 초기화된 문자열을 수정하려는 행
위는 실행 도중에 오류를 발생시킨다:

```
char* str = "Hello, World!";
str[5] = ’w’;
printf("%s", str);
```


이처럼 실행 도중에 발생하는 오류를 런타임(runtime) 오류, C 언어의 문
법적인 제약을 위반해 발생한 오류를 컴파일(compile-time, compilation) 오류
라고 부른다.

## 문자열의 끝, NULL 문자

C 언어에서 문자열은 단순한 바이트열3이므로, 문자열의 길이를 저장하는 수
단이 없다. 문자열의 길이를 따로 저장하는 수단 없이 문자열 자체에 내포하기
위해 문자열의 마지막에 NULL 문자, 0을 삽입함으로써 문자열의 마지막을
표현한다.

## 문자열 변수의 초기화

C 언어에서 문자열은 글자(char)의 나열이므로, char[]형 변수에 저장하고
char*로 가리킬 수 있다.

```
char str[] = "Hello, World!";
str = "Bye, World...";
```

그러나, 위 코드는 올바른 C 코드가 아니다. char[]형 변수에 문자열을
저장하는 것은 오직 char[]형 변수가 초기화될 때만 가능하기 때문이다. (첫
줄은 허용되나, 두번째 줄은 허용되지 않는다)

이는 변수의 초기화와 대입이 엄밀히 분리되는 까닭이며, 또한 어떤 배열에
문자열이 대입되는 것이 엄밀하게 정의되기 어렵기 때문이다. (엄밀히 정의되
기 어렵거나, 기계어와 쉽게 대응되지 않는 명령은 C 언어에서 기본적으로
지원되지 않는다)

```
char* str = "Hello, World!";
str = "Bye, World...";
```

반대로, 문자열 리터럴로 char*형 변수를 초기화했다고 생각해보자. 포인
터 변수에 대한 문자열 리터럴의 대입은 이미 특수한 공간에 할당된 문자열의
주소를 포인터 변수에 대입하는 것으로 해석할 수 있으므로, 포인터 변수에
문자열 리터럴을 대입하는 것은 허용된다.

따라서, 위 예제에 문법적 오류는 없다.

## 문자열 변수의 대입

그렇다면, 배열에 어떻게 문자열을 대입할 수 있을까? 단순무식한 C 언어의
철학을 부수고 뜯어 고치는 대신, 아래와 같은 새로운 함수를 구현해 간단하게
해결할 수 있을 것이다:

```
void strcpy(char* dst, char* src)
{
    while (*dst++ = *src++);
}
int main()
{
    char str[64];
    strcpy(str, "Hello, World!");
    printf("%s", str);
    return 0;
}
```

구현된 함수 strcpy는 dst와 src가 가리키는 문자를 하나씩 뒤로 미루며
src의 값을 dst에 복사한다.

대입연산자(=)를 이용한 식(*dst++ = *src++) 또한 일종의 식(expression)
이기 때문에, 반환값4이 존재한다. 대입연산자를 이용한 식 a = b의 반환값은
변화한 a이기 때문에, 우리가 이용한 식 *dst++ = *src++은 현재 *src를 현
재 *dst에 저장하고, src와 dst가 각각 다음 글자를 가리키게 하며, *dst에
대입된 글자가 0, NULL 문자라면 반복문을 탈출하도록 한다.

마지막으로, strcpy를 사용하기위해 매개변수에 문자 배열을 사용하면, 문
자 배열이 문자 포인터로 부식되며 strcpy에서 사용하기 쉬운 형태로 가공된
다. main에서 정의된 char str[64]와 strcpy에서 정의된 dst는 char* dst = str
정도의 관계를 가지는 서로 다른 두 변수라고 생각하자.

## 문자열을 쉽게 다루는 함수들

사실, 우리가 구현한 strcpy를 비롯해, 문자를 쉽게 다루기 위한 여러 함수들이
이미 준비되어있다.

```
...
#include <string.h>
...
int main()
{
char str[64] = "Hello, World!";
for (int i = 0; i < strlen(str); ++i)
printf("%c", str[i]);
}
```

위는 문자열 관련 함수들을 불러오고(#include <string.h>), 변수 i를 0
부터 문자열의 길이(strlen(str) - 1)까지 증가시키며, 해당하는 번째의 문
자를 출력하는 예제다.

